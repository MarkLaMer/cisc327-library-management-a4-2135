import random
import pygame

# ----------------------------
# CONFIG (small & fast)
# ----------------------------
WIDTH, HEIGHT   = 800, 600
TILE            = 8
COLS, ROWS      = WIDTH // TILE, HEIGHT // TILE
SEED            = 42
MIN_LEAF        = 10          # minimum leaf side (tiles)
MAX_LEAF        = 30          # target-ish max leaf side (tiles)
ROOM_MARGIN     = 1           # keep rooms within leaf by this margin (tiles)

COLOR_BG        = (25, 120, 160)
COLOR_FLOOR     = (230, 230, 230)
COLOR_HALL      = (210, 210, 210)

# ----------------------------
# Minimal BSP (dict nodes)
# ----------------------------
def make_node(x, y, w, h):
    return {"x": x, "y": y, "w": w, "h": h,
            "left": None, "right": None, "room": None,
            "orient": None, "cut_at": None}

def split(node):
    """Try to split node into children; record orientation and cut line."""
    if node["left"] or node["right"]:
        return False

    x, y, w, h = node["x"], node["y"], node["w"], node["h"]

    if w / h >= 1.25:
        horiz = False
    elif h / w >= 1.25:
        horiz = True
    else:
        horiz = random.choice([True, False])

    extent = (h if horiz else w) - MIN_LEAF
    if extent <= MIN_LEAF:
        return False

    cut = random.randint(MIN_LEAF, extent)

    if horiz:
        node["left"]  = make_node(x, y, w, cut)
        node["right"] = make_node(x, y + cut, w, h - cut)
        node["orient"] = "H"
        node["cut_at"] = y + cut           # y of split
    else:
        node["left"]  = make_node(x, y, cut, h)
        node["right"] = make_node(x + cut, y, w - cut, h)
        node["orient"] = "V"
        node["cut_at"] = x + cut           # x of split

    return True

def create_rooms(node):
    """Create 1 room per terminal leaf (simple clamped random)."""
    if node["left"] or node["right"]:
        if node["left"]:  create_rooms(node["left"])
        if node["right"]: create_rooms(node["right"])
        return

    bx, by, bw, bh = node["x"], node["y"], node["w"], node["h"]
    minw = minh = 4
    avail_w = max(minw, bw - 2 * ROOM_MARGIN)
    avail_h = max(minh, bh - 2 * ROOM_MARGIN)

    rw = random.randint(minw, min(avail_w, MAX_LEAF))
    rh = random.randint(minh, min(avail_h, MAX_LEAF))

    minx = bx + ROOM_MARGIN
    miny = by + ROOM_MARGIN
    maxx = (bx + bw - ROOM_MARGIN) - rw
    maxy = (by + bh - ROOM_MARGIN) - rh
    if maxx < minx: maxx = minx
    if maxy < miny: maxy = miny

    rx = random.randint(minx, maxx)
    ry = random.randint(miny, maxy)
    node["room"] = (rx, ry, rw, rh)  # (x,y,w,h) in tile coords

def list_rooms(node):
    """Collect room rects under this subtree."""
    out = []
    stack = [node]
    while stack:
        n = stack.pop()
        if n["room"]:
            out.append(n["room"])
        if n["left"]:  stack.append(n["left"])
        if n["right"]: stack.append(n["right"])
    return out

def room_center(room):
    x, y, w, h = room
    return (x + w // 2, y + h // 2)

def manhattan(a, b):
    (ax, ay), (bx, by) = a, b
    return abs(ax - bx) + abs(ay - by)

def closest_pair(roomsA, roomsB):
    best = None
    bestd = 10**9
    for ra in roomsA:
        ca = room_center(ra)
        for rb in roomsB:
            cb = room_center(rb)
            d = manhattan(ca, cb)
            if d < bestd:
                bestd = d
                best = (ra, rb)
    return best

def connect_siblings(node, connected_pairs, corridors):
    """Connect left/right subtrees once via the split line; recurse."""
    left, right = node.get("left"), node.get("right")

    if left and right:
        roomsL = list_rooms(left)
        roomsR = list_rooms(right)
        if roomsL and roomsR:
            ra, rb = closest_pair(roomsL, roomsR)
            ca = room_center(ra)
            cb = room_center(rb)

            key = tuple(sorted([ca, cb]))
            if key not in connected_pairs:
                connected_pairs.add(key)

                orient = node.get("orient")
                cut_at = node.get("cut_at")
                if orient == "V":
                    elbow_a = (cut_at, ca[1])
                    elbow_b = (cut_at, cb[1])
                    poly = [ca, elbow_a, elbow_b, cb]
                elif orient == "H":
                    elbow_a = (ca[0], cut_at)
                    elbow_b = (cb[0], cut_at)
                    poly = [ca, elbow_a, elbow_b, cb]
                else:
                    poly = [ca, (cb[0], ca[1]), cb]  # fallback L

                # compact consecutive duplicates
                compact = [poly[0]]
                for p in poly[1:]:
                    if p != compact[-1]:
                        compact.append(p)
                corridors.append(compact)

    if left:  connect_siblings(left,  connected_pairs, corridors)
    if right: connect_siblings(right, connected_pairs, corridors)

def build_bsp(seed=SEED):
    if seed is not None:
        random.seed(seed)
    root = make_node(0, 0, COLS, ROWS)

    leaves = [root]
    changed = True
    while changed:
        changed = False
        nxt = []
        for n in leaves:
            if (n["w"] > MAX_LEAF or n["h"] > MAX_LEAF or random.random() > 0.5) and split(n):
                nxt.extend([n["left"], n["right"]])
                changed = True
            else:
                nxt.append(n)
        leaves = nxt

    create_rooms(root)
    corridors, connected_pairs = [], set()
    connect_siblings(root, connected_pairs, corridors)
    return root, leaves, corridors

# ----------------------------
# DRAW
# ----------------------------
def draw_dungeon(screen, root, corridors):
    screen.fill(COLOR_BG)

    # rooms
    stack = [root]
    while stack:
        n = stack.pop()
        if n["room"]:
            rx, ry, rw, rh = n["room"]
            pygame.draw.rect(
                screen, COLOR_FLOOR,
                pygame.Rect(rx*TILE, ry*TILE, rw*TILE, rh*TILE)
            )
        if n["left"]:  stack.append(n["left"])
        if n["right"]: stack.append(n["right"])

    # corridors (polylines)
    width = max(5, TILE // 3)
    for poly in corridors:
        for i in range(len(poly) - 1):
            (ax, ay) = poly[i]
            (bx, by) = poly[i+1]
            pygame.draw.line(
                screen, COLOR_HALL,
                (ax*TILE, ay*TILE), (bx*TILE, by*TILE),
                width
            )

# ----------------------------
# MAIN
# ----------------------------
def main():
    pygame.init()
    screen = pygame.display.set_mode((WIDTH, HEIGHT))
    pygame.display.set_caption("Lean BSP Dungeon (Split-Line Corridors)")
    clock = pygame.time.Clock()

    root, leaves, corridors = build_bsp(SEED)

    running = True
    while running:
        for e in pygame.event.get():
            if e.type == pygame.QUIT:
                running = False
            elif e.type == pygame.KEYDOWN and e.key == pygame.K_r:
                root, leaves, corridors = build_bsp(random.randint(0, 10_000))

        draw_dungeon(screen, root, corridors)
        pygame.display.flip()
        clock.tick(60)

    pygame.quit()

if __name__ == "__main__":
    main()
